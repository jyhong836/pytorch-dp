"""Standard DP."""
from __future__ import annotations
import numpy as np
from typing import List, Tuple, Union, TYPE_CHECKING

from .base import PrivacyMetric


class DP(PrivacyMetric):
    """Approximated DP"""
    def __init__(self, eps=1.6, delta=1e-8):
        if eps is None:
            eps = np.inf
        super().__init__(eps=eps, delta=delta)

    @property
    def eps(self) -> float:
        return self.params['eps']

    @property
    def delta(self) -> float:
        return self.params['delta']

    def to_dp(self, delta) -> DP:
        assert delta == self.delta, "Only support transformation with the same `delta`."
        return DP(self.eps, self.delta)

    @classmethod
    def from_dp(cls, dp_metric: DP) -> PrivacyMetric:
        return cls(**dp_metric.params)

    @classmethod
    def compose(cls, privacy_metrics: List[PrivacyMetric]) -> PrivacyMetric:
        # TODO implement the strong composition theory.
        raise NotImplementedError

    def privater_than(self, other: DP) -> bool:
        return self.eps < other.eps and self.delta < other.delta

    @classmethod
    def from_sigma(cls, sigma, C=1.) -> PrivacyMetric:
        """Create metric from given noise scale."""
        # TODO implement this.

    @classmethod
    def from_param_tuple(cls, params: Tuple) -> PrivacyMetric:
        """Construct a privacy metric from an ordered parameter tuple.
        **NOTE**: This is only compatible with the tuple generated by `to_param_tuple`."""
        return cls(eps=params[0], delta=params[1])

    def to_param_tuple(self) -> Tuple[float, float]:  # TODO use namedtuple.
        """Generate tuple enclosing the privacy parameters."""
        return self.eps, self.delta

    def param_tuple_keys(self) -> Tuple:
        return 'eps', 'delta'

    @classmethod
    def num_param(cls) -> int:
        """Return the number of parameters."""
        return 2

    @classmethod
    def zero(cls) -> PrivacyMetric:
        """Create an instance represent the zero-privacy cost."""
        return cls.from_param_tuple(tuple([0] * cls.num_param()))


class DPMA(DP):
    """DP with moment accoutant"""
    pass
