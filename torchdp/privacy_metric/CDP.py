"""Concentrated DP."""
from __future__ import annotations
import numpy as np
from typing import List, Tuple, Union
import logging
from math import log, sqrt
from scipy.optimize import fsolve

from .base import PrivacyMetric, DPPropertyNotAvaiableError
from .DP import DP

logger = logging.getLogger(__name__)


def dp_to_zcdp(eps, delta):
    """Translate DP to zCDP."""
    if eps is None or eps == np.inf:
        return np.inf

    def eq_epsilon(rho):
        """
        rho-zCDP => (rho + 2*sqrt(rho * ln(1/delta)), delta)-DP
        """
        if rho <= 0.0:
            rhs = rho
        else:
            rhs = rho + 2.0 * sqrt(rho * log(1.0/delta))

        return eps - rhs

    rho = fsolve(eq_epsilon, 0.0)

    return rho[0]


class zCDP(PrivacyMetric):
    def __init__(self, rho=10.):
        super().__init__(rho=rho)

    @property
    def rho(self) -> Union[float]:
        return self.params['rho']

    def to_dp(self, delta=1e-8):
        return DP(eps=self.rho + 2 * np.sqrt(self.rho * np.log(1 / delta)), delta=delta)

    @classmethod
    def from_dp(cls, dp_metric: DP) -> zCDP:
        # return zCDP(rho=dp_metric.params["eps"]**2/2)
        return cls(rho=dp_to_zcdp(dp_metric.eps, dp_metric.delta))

    @classmethod
    def compose(cls, privacy_metrics: List[zCDP]) -> zCDP:
        assert len(privacy_metrics) > 0, "An empty list of privacy metrics cannot be composed."
        return cls(rho=sum([pm.rho for pm in privacy_metrics]))

    def decompose(self, T: int) -> zCDP:
        return zCDP(rho=self.rho / T)

    def privater_than(self, other: zCDP) -> bool:
        return self.rho < other.rho

    def to_sigma(self, C=1., approximate=False) -> Union[float]:
        return C / sqrt(2. * self.rho)

    @classmethod
    def from_sigma(cls, sigma, C=1.) -> zCDP:
        return cls(rho=C ** 2 / 2. / sigma ** 2)

    @classmethod
    def from_param_tuple(cls, params: Tuple) -> PrivacyMetric:
        """Construct a privacy metric from an ordered parameter tuple.
        **NOTE**: This is only compatible with the tuple generated by `to_param_tuple`."""
        return cls(rho=params[0])

    def to_param_tuple(self) -> Tuple[float]:  # TODO use namedtuple.
        """Generate tuple enclosing the privacy parameters."""
        return tuple([self.rho])

    def param_tuple_keys(self) -> Tuple:
        return tuple(['rho'])

    @classmethod
    def num_param(cls) -> int:
        """Return the number of parameters."""
        return 1

    @classmethod
    def zero(cls) -> PrivacyMetric:
        """Create an instance represent the zero-privacy cost."""
        return cls.from_param_tuple(tuple([0] * cls.num_param()))

    def get_budget_upper_bound(self, sample_rate: float) -> zCDP:
        """Return the upper bound of allowed privacy budget."""
        return zCDP(rho=np.inf)

    def amp_by_sampling(self, sample_rate: float, batch_type="shuffle") -> zCDP:
        """Privacy amplification by subsampling. This method will return step privacy cost if the step is one
        of an epoch.

        :param sample_rate: Batch size over number of samples.
        :param batch_type: 'shuffle'.
        :return: Return the amplified privacy metric.
        """
        assert batch_type == "shuffle", "For zCDP, only 'shuffle' batch type is implemented."
        return zCDP(rho=self.rho * sample_rate)

    def deamp_by_sampling(self, sample_rate: float, batch_type="shuffle") -> zCDP:
        assert batch_type == "shuffle", "For zCDP, only 'shuffle' batch type is implemented."
        return zCDP(rho=self.rho / sample_rate)


class tCDP(PrivacyMetric):
    def __init__(self, rho=10., rev_omega=1e-5):
        # if not isinstance(rho, tf.Tensor) and not isinstance(rev_omega, tf.Tensor):
        #     assert rho >= 0, f"Found negative rho: {rho}"
        #     assert rev_omega is None or rev_omega >= 0, f"Found negative rev_omega: {rev_omega}"
        super().__init__(rho=rho, rev_omega=rev_omega)

    @property
    def rho(self) -> float:
        return self.params['rho']

    @property
    def rev_omega(self) -> float:
        """`rev_omega` = `1 / omega`."""
        return self.params['rev_omega']

    @property
    def __omega(self):
        return 1 / self.rev_omega

    def to_dp(self, delta):
        eps = self.rho + 2 * sqrt(self.rho * log(1 / delta)) \
            if log(1 / delta) <= np.square(self.__omega - 1) * self.rho \
            else self.rho * self.__omega + log(1 / delta) / (self.__omega - 1)
        return DP(eps, delta)

    @classmethod
    def from_dp(cls, dp_metric: DP, rev_omega: Union[float, str] = "zCDP") -> tCDP:
        """Construct tCDP from DP

        Args:
            dp_metric:
            rev_omega: Float value or one of below str:
                "zCDP": The rev_omega that makes the tCDP degrades as zCDP.
                "tCDP": The max rev_omega that is valid for tCDP.
                float <0: residual added to "tCDP" mode.
                float in [0, 1): A generic rev_omega.
        Return:
            A tCDP instance.
        """
        a = - np.log(dp_metric.delta) / dp_metric.eps
        omega_lb = 1 + a  # tCDP omega lower bound.

        zcdp_rho = dp_to_zcdp(dp_metric.eps, dp_metric.delta)
        zcdp_omega_lb = np.sqrt(- np.log(dp_metric.delta)/zcdp_rho) + 1

        if isinstance(rev_omega, str):
            if rev_omega == "zCDP":
                rev_omega = 1 / zcdp_omega_lb
                logger.debug(f"Use zCDP rev_omega: {rev_omega}")
                # return cls(rho=zcdp_rho, rev_omega=rev_omega)
            elif rev_omega == "tCDP":
                # use the max allowed omega
                residual_rho = 1e-7  # to avoid rho being zero
                rev_omega = 1 / omega_lb - residual_rho
                logger.debug(f"Use max allowed rev_omega: {rev_omega} with residual {residual_rho}")
            else:
                raise ValueError(f"Invalid rev_omega str: {rev_omega}")
        elif rev_omega <= 0:
            residual_rho = - rev_omega
            rev_omega = 1 / omega_lb - residual_rho
            logger.debug(f"Use max allowed rev_omega: {rev_omega} with residual {residual_rho}")
        elif rev_omega >= 1:
            raise ValueError(f"Invalid rev_omega which should be in range (0, 1) or negative for (tCDP) while get"
                             f" {rev_omega}.")
        omega = 1 / rev_omega

        if omega >= zcdp_omega_lb:
            logger.debug("tCDP: Use pure zCDP).")
            return cls(rho=zcdp_rho, rev_omega=rev_omega)
        else:
            omega_ub = (1 + a) + np.sqrt((1 + a) * a)
            def rho1(omega_): return dp_metric.eps * (1 - a / (omega_ - 1)) / omega_
            if omega_lb <= omega <= omega_ub:
                rho1_v = rho1(omega)
                if rho1_v < 0:
                    raise ValueError(f"rho1 < 0: {rho1_v}")
                logger.debug("tCDP: Use case 1.")
                return cls(rho=rho1_v, rev_omega=rev_omega)
            else:
                raise ValueError(f"Rev_omega should be in range {1/omega_ub:g} <= _ <= {1/omega_lb:g} to use case 1. "
                                 f"Otherwise, omega has to be <= {1/zcdp_omega_lb:g} to use case 0 (zCDP).")

    @classmethod
    def compose(cls, privacy_metrics: List[tCDP]) -> tCDP:
        assert len(privacy_metrics) > 0, "An empty list of privacy metrics cannot be composed."
        return cls(rho=sum([pm.rho for pm in privacy_metrics]), rev_omega=max([pm.rev_omega for pm in privacy_metrics]))

    def decompose(self, T: int) -> tCDP:
        return tCDP(rho=self.rho / T, rev_omega=self.rev_omega)
        # TODO The trivial average might be non-optimal for omega.
        # raise DPPropertyNotAvaiableError

    def __sub__(self, other: tCDP) -> tCDP:
        """Return the substraction of the current privacy metric minus the other.

        Implementation note: The substraction should satisfy the equality. That means if A <= B, then their substraction
        A - B <= 0.
        """
        return tCDP(rho=self.rho - other.rho, rev_omega=self.rev_omega - other.rev_omega)

    def privater_than(self, other: tCDP) -> bool:
        return self.rho < other.rho and self.rev_omega < other.rev_omega

    def __get_A(self, sensitivity):
        """In most cases, this could be ignored as infinity."""
        return 8 * sensitivity / self.rev_omega

    @classmethod
    def from_sigma(cls, sigma, C=1.) -> PrivacyMetric:
        """Create metric from given noise scale."""
        # TODO this is a loose setting for tCDP, meaning that a tighter form may exist.
        assert sigma > C / sqrt(2)
        return cls(rho=8. * np.square(C) / np.square(sigma), rev_omega=sqrt(2) * sigma / 8. / C)

    @classmethod
    def canonical_noise(cls, sigma: float = None, shape: Tuple[int] = (), dtype=float,
                        omega=1e-3, sensitivity=3.) \
            -> float:
        """Return the canonical noise."""
        if omega <= 1e-3:
            # approximated by Gaussian.
            return zCDP.canonical_noise(sigma=sigma, shape=shape, dtype=dtype)
        else:
            # TODO implement this.
            raise NotImplementedError

    @classmethod
    def from_param_tuple(cls, params: Tuple) -> PrivacyMetric:
        """Construct a privacy metric from an ordered parameter tuple.
        **NOTE**: This is only compatible with the tuple generated by `to_param_tuple`."""
        return cls(rho=params[0], rev_omega=params[1])

    def to_param_tuple(self) -> Tuple[float, float]:  # TODO use namedtuple.
        """Generate tuple enclosing the privacy parameters."""
        return self.rho, self.rev_omega

    def param_tuple_keys(self) -> Tuple:
        return 'rho', 'rev_omega'

    @classmethod
    def num_param(cls) -> int:
        """Return the number of parameters."""
        return 2

    @classmethod
    def zero(cls) -> PrivacyMetric:
        """Create an instance represent the zero-privacy cost."""
        return cls(rho=0., rev_omega=0.)

    def amp_by_sampling(self, sample_rate: float, batch_type="random") -> tCDP:
        assert batch_type == "random", "For tCDP, only random batch type is implemented."
        return tCDP(rho=13 * self.rho * sample_rate**2, rev_omega=4 * self.rho / log(1/sample_rate))


class ctCDP(tCDP):
    """Simplified constrainted tCDP with constant omega.
    Difference:
        + Compared to zCDP: ctCDP is with a subsampling scale and the trans to DP is different (we choose the different
            one which can get more transformed rho with smaller omega).
        + Compared to tCDP: ctCDP use a constant rev_omega which makes the private noise degraded to zCDP noise.
    Note: If need to translate to DP, initialize ctCDP by using `from_dp`.
    """
    def __init__(self, rho=10.):
        """Recommend to create ctCDP from the `from_dp`.
        """
        super().__init__(rho=rho, rev_omega=None)  # self.default_rev_omega)
        # self.__class__.default_rev_omega = rev_omega
        del self.params["rev_omega"]

    @property
    def rev_omega(self) -> Union[float, None]:
        # return None
        return self.global_rev_omega

    # NOTE: rev_omega is not used, but just for computing the sigma lower bound.
    # The value will be updated only when first time created from_dp.
    global_rev_omega = None
    # global_dp_delta = None

    @classmethod
    def set_global_privacy_params(cls, global_rev_omega: float):
        assert cls.global_rev_omega is None, "Try to reset global_rev_omega which can only be set once."
        cls.global_rev_omega = global_rev_omega
        # assert global_dp_delta is None, "global_dp_delta can only be set once."
        # cls.global_dp_delta = global_dp_delta

    @classmethod
    def num_param(cls) -> int:
        """Return the number of parameters."""
        return 1

    @property
    def __omega(self):
        return 1 / self.rev_omega

    @classmethod
    def compose(cls, privacy_metrics: List[ctCDP]) -> tCDP:
        assert len(privacy_metrics) > 0, "An empty list of privacy metrics cannot be composed."
        return cls(rho=sum([pm.rho for pm in privacy_metrics]))

    def decompose(self, T: int) -> ctCDP:
        return ctCDP(rho=self.rho / T)

    def __sub__(self, other: ctCDP) -> ctCDP:
        """Return the substraction of the current privacy metric minus the other.

        Implementation note: The substraction should satisfy the equality. That means if A <= B, then their substraction
        A - B <= 0.
        """
        return ctCDP(rho=self.rho - other.rho)

    def privater_than(self, other: ctCDP) -> bool:
        return self.rho < other.rho

    @classmethod
    def from_tcdp(cls, tcdp: tCDP) -> ctCDP:
        return ctCDP(rho=tcdp.rho)

    default_rev_omega_from_dp = "zCDP"

    @classmethod
    def from_dp(cls, dp_metric: DP) -> ctCDP:
        tcdp = tCDP.from_dp(dp_metric, rev_omega=cls.default_rev_omega_from_dp)
        rev_omega = tcdp.rev_omega
        cls.set_global_privacy_params(rev_omega)
        return cls.from_tcdp(tcdp)

    def get_budget_upper_bound(self, sample_rate: float = 1.) -> ctCDP:
        """This is used for estimate the sigma lower bound if the current privacy metric is the **total budget**."""
        self.validate_sample_rate(sample_rate)
        if 1. - sample_rate < 1e-7:
            return ctCDP(rho=np.inf)
        rev_omega = self.global_rev_omega
        # delta = self.global_dp_delta
        rho_ub = log(1 / sample_rate) * rev_omega / 4.  # apply the upper bound to hat rho (step rho or step sigma).
        return ctCDP(rho=rho_ub)  # .to_sigma(C=C, approximate=approximate)

    # def estimate_sigma_from_span(self, span: Span) -> float:
        # TODO the span is fixed to be around 300 which should be more flexible.
        # TODO constraint the lower bound and upper bound instead of just estimating a sigma.

    @classmethod
    def from_sigma(cls, sigma, C=1.) -> ctCDP:
        """Create metric from given noise scale."""
        return cls(rho=.5 * (C / sigma) ** 2)

    def to_sigma(self, C=1., approximate=False) -> float:
        return C / sqrt(2. * self.rho)

    @classmethod
    def from_param_tuple(cls, params: Tuple) -> PrivacyMetric:
        """Construct a privacy metric from an ordered parameter tuple.
        **NOTE**: This is only compatible with the tuple generated by `to_param_tuple`."""
        return cls(rho=params[0])

    def to_param_tuple(self) -> Tuple[float]:  # TODO use namedtuple.
        """Generate tuple enclosing the privacy parameters."""
        return tuple([self.rho])

    def param_tuple_keys(self) -> Tuple:
        return tuple(['rho'])

    @classmethod
    def zero(cls) -> PrivacyMetric:
        """Create an instance represent the zero-privacy cost."""
        return cls(rho=0.)

    # def validate_sample_rate(self, sample_rate: float) -> bool:
    #     """Return true if sample rate is proper.
    #     **NOTE**: It is recommended to validate this for the total_budget and ignore the invalidation during training.
    #         When total budget is constrained, then the decomposed budget will auto fit the vlidation condition.
    #
    #     :return: True if validated.
    #     :raise: ValueError if validation fails.
    #     """
    #     ret = self.rev_omega >= self.rho / np.log(1 / sample_rate)
    #     if not ret:
    #         raise ValueError(f"Given sample_rate as {sample_rate}, the rho should be <= "
    #                          f"{self.rev_omega * np.log(1 / sample_rate)}. Alternatively, given rho as "
    #                          f"{self.rho}, the sample rate should be <= {np.exp(-self.rho / self.rev_omega)}")
    #     return ret

    # This value should be calibrated by MA. See privacy_metric_test.py: test_RS_sampling_valid.
    # SAMPLING_AMP_SCALE = 1.03
    SAMPLING_AMP_SCALE = 2.

    def amp_by_sampling(self, sample_rate: float, batch_type="random") -> ctCDP:
        if sample_rate == 1.:
            return self
        self.validate_sample_rate(sample_rate)
        assert batch_type == "random", "For ctCDP, only random batch type is implemented."
        # if isinstance(sample_rate, tf.Tensor):
        #     # ass = tf.assert_greater_equal(self.rev_omega, 4 * self.rho / tf.log(1. / sample_rate),
        #     #                               message="Invalid sample rate for the fixed rev_omega.")
        #     # with tf.control_dependencies([ass]):
        #         return tCDPx(rho=13*self.rho * sample_rate**2)
        # else:
        # TODO the assertion may fail. We only constraint the rho to satisfy the condition for simplicity.
        #     assert self.rev_omega * np.log(1 / sample_rate) / 4 >= self.rho , "Invalid sample rate for the fixed " \
        #                                                                      "rev_omega."
        # These should be checked using MA.
        # return ctCDP(rho=13. * self.rho * sample_rate ** 2)
        return ctCDP(rho=self.SAMPLING_AMP_SCALE * self.rho * sample_rate ** 2)
        # return ctCDP(rho=self.rho * sample_rate ** 2)

    def deamp_by_sampling(self, sample_rate: float, batch_type="random") -> PrivacyMetric:
        assert batch_type == "random"
        return ctCDP(rho=self.rho / (self.SAMPLING_AMP_SCALE * sample_rate ** 2))  # (13. * sample_rate ** 2))
        # return ctCDP(rho=self.rho / (13. * sample_rate ** 2))
