"""Metric definitions"""
from __future__ import annotations
import abc
import numpy as np
from typing import List, Tuple, Union, TYPE_CHECKING

if TYPE_CHECKING:
    from .DP import DP


class DPPropertyNotAvaiableError(Exception):
    """DP property not availabl error."""
    pass


class DPOutOfBudgetError(Exception):
    """Raise when DP privacy budget has been used up."""
    pass

# PrivacyMetricTuple = Tuple  # TODO repalce with namedtuple


class PrivacyMetric(metaclass=abc.ABCMeta):
    """Differential Privacy metric."""
    def __init__(self, **params):
        self.params = params

    def __repr__(self):
        return ", ".join([f"{k}: {v:g}" for k, v in self.params.items()])

    def __format__(self, format_spec):
        return ", ".join([f"{k}: {v.__format__(format_spec)}" for k, v in self.params.items()])

    @classmethod
    @abc.abstractmethod
    def from_param_tuple(cls, params: Tuple) -> PrivacyMetric:
        """Construct a privacy metric from an ordered parameter tuple.
        **NOTE**: This is only compatible with the tuple generated by `to_param_tuple`."""
        pass

    @abc.abstractmethod
    def to_param_tuple(self) -> Tuple[float]:  # TODO use namedtuple.
        """Generate tuple enclosing the privacy parameters."""
        pass

    @abc.abstractmethod
    def param_tuple_keys(self) -> Tuple:
        pass

    @classmethod
    @abc.abstractmethod
    def num_param(cls) -> int:
        """Return the number of parameters."""
        return 0

    @property
    def name(self):
        return self.__class__.__name__

    @abc.abstractmethod
    def to_dp(self, delta) -> DP:
        pass
        # eps = 1.0
        # delta = 0
        # return DP(eps=eps, delta=delta)

    def to_sigma(self, C=1., approximate=False) -> float:
        """Return the noise scale. The noise form should be defined by `canonical_noise`.

        :param C:
        :param approximate: Only use approximate estimation of the noise if True. If the estimation is simple, then
            the approximate estimation will be the same as the exact estimation.
        """
        raise DPPropertyNotAvaiableError("")

    @classmethod
    @abc.abstractmethod
    def from_sigma(cls, sigma, C=1.) -> PrivacyMetric:
        """Create metric from given noise scale.

        :param sigma: Noise scale which is used in the `canonical_noise`.
        :param C: The constant multiplier which usually is the L2 sensitivity."""
        pass

    @classmethod
    def canonical_noise(cls, sigma: float = None, shape: Tuple[int] = (), dtype=float) \
            -> np.ndarray:
        """Return the canonical noise."""
        # TODO add l2 sensitivity such that sigma is only about identity input.
        return sigma * np.random.randn(shape)

    @classmethod
    @abc.abstractmethod
    def from_dp(cls, dp_metric: DP) -> PrivacyMetric:
        pass

    @classmethod
    @abc.abstractmethod
    def compose(cls, privacy_metrics: List[PrivacyMetric]) -> PrivacyMetric:
        pass

    def decompose(self, T: int) -> PrivacyMetric:
        """Uniformly decompose the privacy metric into steps when the total number of steps is `span`."""
        raise DPPropertyNotAvaiableError(f"{self.name} can not be decmposed.")

    def amp_by_sampling(self, sample_rate: float, batch_type="random") -> PrivacyMetric:
        """Privacy amplification by subsampling.

        :param sample_rate: Batch size over number of samples.
        :param batch_type: 'shuffle' or 'random'.
        :return: Return the amplified privacy metric.
        """
        raise DPPropertyNotAvaiableError

    def deamp_by_sampling(self, sample_rate: float, batch_type="random") -> PrivacyMetric:
        """The reverse operation of amp_by_sampling."""
        raise DPPropertyNotAvaiableError

    def get_budget_upper_bound(self, sample_rate: Union[float, tf.Tensor] = 1.) -> PrivacyMetric:
        """Return the upper bound of allowed privacy budget.

        :param sample_rate: Float value in (0, 1]. If is 1., then should return a infinite upper bound.
        """
        # if abs(1 - sample_rate) < 1e-7:
        #     return np.inf
        raise DPPropertyNotAvaiableError

    # DEPRECATED: Directly use the two methods instead of using this.
    # def estimate_sigma_from_span(self, span: Span) -> float:
    #     """Estimate step noise scale, sigma, given the span and assuming privacy budget is allocated uniformly."""
    #     step_budget = self.decompose(span)
    #     return step_budget.to_sigma(approximate=True)

    # ///// operations ////
    @classmethod
    @abc.abstractmethod
    def zero(cls) -> PrivacyMetric:
        """Create an instance represent the zero-privacy cost."""
        pass
        # return cls.from_param_tuple(tuple([0] * cls.num_param()))

    def __eq__(self, other: PrivacyMetric) -> bool:
        return all([self.params[k] == other.params[k] for k in self.params])

    def __ne__(self, other: PrivacyMetric) -> bool:
        return any([self.params[k] != other.params[k] for k in self.params])

    def __lt__(self, other: PrivacyMetric) -> bool:
        """<: more private."""
        return self.privater_than(other)

    def __gt__(self, other: PrivacyMetric) -> bool:
        """>: less private."""
        return not self.privater_than(other)

    def __sub__(self, other: PrivacyMetric) -> PrivacyMetric:
        """Return the substraction of the current privacy metric minus the other.

        Implementation note: The substraction should satisfy the equality. That means if A <= B, then their substraction
        A - B <= 0.
        """
        return type(self)(**{k: self.params[k] - other.params[k] for k in self.params})

    def __floordiv__(self, other):
        return type(self)(**{k: self.params[k] // other.params[k] for k in self.params})

    def __truediv__(self, other):
        return type(self)(**{k: self.params[k] / other.params[k] for k in self.params})

    def apply(self, func):
        """Apply `func` to every element in the `params` dict. Return updated self."""
        self.params = {k: func(v) for k, v in self.params.items()}
        return self

    @abc.abstractmethod
    def privater_than(self, other: PrivacyMetric) -> bool:
        """Return True if the current privacy metric is privater than (excluding `as private as`) the `other`."""
        pass

    @classmethod
    def validate_sample_rate(cls, smp_rate):
        """Raise ValueError if sample rate is not in a correct range"""
        if not (0 < smp_rate <= 1):
            raise ValueError(f"Invalid sample rate: {smp_rate}.")

    @staticmethod
    def factory(metric_name: str, dp_eps: float, dp_delta: float):
        raise ValueError("Not supported")  # to avoid import cyclic of DP.
        # if metric_name in dir(sys.modules[__name__]):
        #     metric_cls = getattr(sys.modules[__name__], metric_name)
        #     return metric_cls.from_dp(DP(eps=dp_eps, delta=dp_delta))
